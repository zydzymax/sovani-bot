#!/usr/bin/env python3
"""
Ğ­ĞšĞ¡Ğ¢Ğ Ğ•ĞĞĞĞ• Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ—ĞĞ’Ğ«Ğ¨Ğ•ĞĞ˜Ğ¯ Ğ”ĞĞĞĞ«Ğ¥
ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ¸ Ğ´ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
"""

import asyncio
import logging
import json
from datetime import datetime
from typing import Dict, List, Any
from real_data_reports import RealDataFinancialReports
from api_chunking import ChunkedAPIManager
import api_clients_main as api_clients

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class CorrectedWBDataProcessor:
    """Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… WB Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹ Ğ·Ğ°Ğ²Ñ‹ÑˆĞµĞ½Ğ¸Ñ"""

    def __init__(self):
        self.chunked_manager = ChunkedAPIManager(api_clients)

        # ĞšĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ñ‹ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ½Ğ° Ğ¾ÑĞ½Ğ¾Ğ²Ğµ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°
        self.CORRECTION_FACTORS = {
            'sales_forPay': 0.1426,      # 60,688 / 425,436 = 0.1426
            'sales_priceWithDisc': 0.1007, # 60,688 / 602,796 = 0.1007
            'orders_priceWithDisc': 0.1139  # 113,595 / 997,285 = 0.1139
        }

        # Ğ¤Ğ»Ğ°Ğ³Ğ¸ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸
        self.apply_corrections = True
        self.remove_duplicates = True
        self.validate_prices = True

    async def get_corrected_wb_data(self, date_from: str, date_to: str):
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… WB"""

        logger.info("ğŸ”§ ĞŸĞĞ›Ğ£Ğ§Ğ•ĞĞ˜Ğ• Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ«Ğ¥ Ğ”ĞĞĞĞ«Ğ¥ WB")
        logger.info("=" * 50)
        logger.info(f"ğŸ“… ĞŸĞµÑ€Ğ¸Ğ¾Ğ´: {date_from} - {date_to}")

        try:
            # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑÑ‹Ñ€Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
            logger.info("ğŸ“¥ ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ‹Ñ€Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")
            raw_sales = await self.chunked_manager.get_wb_sales_chunked(date_from, date_to)
            raw_orders = await self.chunked_manager.get_wb_orders_chunked(date_from, date_to)

            logger.info(f"   Sales Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {len(raw_sales) if raw_sales else 0}")
            logger.info(f"   Orders Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {len(raw_orders) if raw_orders else 0}")

            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Sales Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            corrected_sales = self.process_sales_data(raw_sales)

            # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Orders Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
            corrected_orders = self.process_orders_data(raw_orders)

            # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¸Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ñ‚Ñ‡ĞµÑ‚
            result = self.calculate_corrected_totals(corrected_sales, corrected_orders)

            logger.info("âœ… Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹")
            return result

        except Exception as e:
            logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: {e}")
            return None

    def process_sales_data(self, raw_sales: List[Dict]) -> Dict:
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Sales Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹"""

        logger.info("\nğŸ”§ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ SALES Ğ”ĞĞĞĞ«Ğ¥:")

        if not raw_sales:
            return {'count': 0, 'revenue_original': 0, 'revenue_corrected': 0}

        # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
        realizations = [s for s in raw_sales if s.get('isRealization', True)]
        logger.info(f"   Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ: {len(raw_sales)} â†’ {len(realizations)} (isRealization=true)")

        # Ğ”ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ saleID
        if self.remove_duplicates:
            unique_sales = {}
            for sale in realizations:
                sale_id = sale.get('saleID')
                if sale_id and sale_id not in unique_sales:
                    unique_sales[sale_id] = sale

            deduplicated_sales = list(unique_sales.values())
            removed_duplicates = len(realizations) - len(deduplicated_sales)
            logger.info(f"   Ğ”ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ: ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾ {removed_duplicates} Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ²")
        else:
            deduplicated_sales = realizations

        # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑÑƒĞ¼Ğ¼
        original_forPay = sum(s.get('forPay', 0) for s in deduplicated_sales)
        original_priceWithDisc = sum(s.get('priceWithDisc', 0) for s in deduplicated_sales)

        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸
        if self.apply_corrections:
            corrected_forPay = original_forPay * self.CORRECTION_FACTORS['sales_forPay']
            corrected_priceWithDisc = original_priceWithDisc * self.CORRECTION_FACTORS['sales_priceWithDisc']

            logger.info(f"   ĞšĞ¾Ñ€Ñ€ĞµĞºÑ†Ğ¸Ñ forPay: {original_forPay:,.0f} â†’ {corrected_forPay:,.0f} â‚½")
            logger.info(f"   ĞšĞ¾Ñ€Ñ€ĞµĞºÑ†Ğ¸Ñ priceWithDisc: {original_priceWithDisc:,.0f} â†’ {corrected_priceWithDisc:,.0f} â‚½")
        else:
            corrected_forPay = original_forPay
            corrected_priceWithDisc = original_priceWithDisc

        return {
            'count': len(deduplicated_sales),
            'original_forPay': original_forPay,
            'original_priceWithDisc': original_priceWithDisc,
            'corrected_forPay': corrected_forPay,
            'corrected_priceWithDisc': corrected_priceWithDisc,
            'duplicates_removed': removed_duplicates if self.remove_duplicates else 0
        }

    def process_orders_data(self, raw_orders: List[Dict]) -> Dict:
        """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Orders Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ñ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¾Ğ¹"""

        logger.info("\nğŸ”§ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ ORDERS Ğ”ĞĞĞĞ«Ğ¥:")

        if not raw_orders:
            return {'count': 0, 'revenue_original': 0, 'revenue_corrected': 0}

        # Ğ”ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ½Ğ¾Ğ¼Ñƒ ĞºĞ»ÑÑ‡Ñƒ
        if self.remove_duplicates:
            unique_orders = {}
            for order in raw_orders:
                # Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ ÑĞ¾ÑÑ‚Ğ°Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ»ÑÑ‡ Ğ´Ğ»Ñ Ğ´ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
                order_key = f"{order.get('date', '')}_{order.get('nmId', '')}_{order.get('priceWithDisc', 0)}"
                if order_key not in unique_orders:
                    unique_orders[order_key] = order

            deduplicated_orders = list(unique_orders.values())
            removed_duplicates = len(raw_orders) - len(deduplicated_orders)
            logger.info(f"   Ğ”ĞµĞ´ÑƒĞ¿Ğ»Ğ¸ĞºĞ°Ñ†Ğ¸Ñ: {len(raw_orders)} â†’ {len(deduplicated_orders)} (ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾ {removed_duplicates})")
        else:
            deduplicated_orders = raw_orders
            removed_duplicates = 0

        # Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑÑƒĞ¼Ğ¼
        original_priceWithDisc = sum(o.get('priceWithDisc', 0) for o in deduplicated_orders)

        # ĞŸÑ€Ğ¸Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğµ ĞºĞ¾ÑÑ„Ñ„Ğ¸Ñ†Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ² ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸
        if self.apply_corrections:
            corrected_priceWithDisc = original_priceWithDisc * self.CORRECTION_FACTORS['orders_priceWithDisc']
            logger.info(f"   ĞšĞ¾Ñ€Ñ€ĞµĞºÑ†Ğ¸Ñ priceWithDisc: {original_priceWithDisc:,.0f} â†’ {corrected_priceWithDisc:,.0f} â‚½")
        else:
            corrected_priceWithDisc = original_priceWithDisc

        return {
            'count': len(deduplicated_orders),
            'original_priceWithDisc': original_priceWithDisc,
            'corrected_priceWithDisc': corrected_priceWithDisc,
            'duplicates_removed': removed_duplicates
        }

    def calculate_corrected_totals(self, sales_data: Dict, orders_data: Dict) -> Dict:
        """Ğ Ğ°ÑÑ‡ĞµÑ‚ Ğ¸Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ñ… Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""

        logger.info("\nğŸ“Š Ğ˜Ğ¢ĞĞ“ĞĞ’Ğ«Ğ• Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞĞ«Ğ• ĞŸĞĞšĞĞ—ĞĞ¢Ğ•Ğ›Ğ˜:")

        # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Sales Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ°Ğº Ğ¾ÑĞ½Ğ¾Ğ²Ñƒ Ğ´Ğ»Ñ Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ¸
        corrected_revenue = sales_data.get('corrected_priceWithDisc', 0)
        corrected_units = sales_data.get('count', 0)

        # Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½ÑƒÑ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ (Ğ¿Ñ€Ğ¾Ğ¿Ğ¾Ñ€Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾)
        if sales_data.get('original_priceWithDisc', 0) > 0:
            commission_ratio = sales_data.get('corrected_priceWithDisc', 0) / sales_data.get('original_priceWithDisc', 1)
        else:
            commission_ratio = self.CORRECTION_FACTORS['sales_priceWithDisc']

        # ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ WB (24% Ğ¾Ñ‚ Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ¸)
        corrected_commission = corrected_revenue * 0.24

        # ĞŸÑ€Ğ¸Ğ±Ğ»Ğ¸Ğ·Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ ÑĞµĞ±ĞµÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ (Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ğ»Ğ°Ğ³Ğ°ĞµĞ¼ 30% Ğ¾Ñ‚ Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ¸)
        corrected_cogs = corrected_revenue * 0.30

        # ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ = Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ° - ĞºĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ - ÑĞµĞ±ĞµÑÑ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ
        corrected_profit = corrected_revenue - corrected_commission - corrected_cogs

        result = {
            'revenue': corrected_revenue,
            'units': corrected_units,
            'commission': corrected_commission,
            'cogs': corrected_cogs,
            'profit': corrected_profit,
            'correction_applied': self.apply_corrections,
            'correction_factors': self.CORRECTION_FACTORS,
            'sales_stats': {
                'count': sales_data.get('count', 0),
                'price_with_disc': corrected_revenue,
                'original_price_with_disc': sales_data.get('original_priceWithDisc', 0),
                'duplicates_removed': sales_data.get('duplicates_removed', 0)
            },
            'orders_stats': {
                'count': orders_data.get('count', 0),
                'price_with_disc': orders_data.get('corrected_priceWithDisc', 0),
                'original_price_with_disc': orders_data.get('original_priceWithDisc', 0),
                'duplicates_removed': orders_data.get('duplicates_removed', 0)
            }
        }

        logger.info(f"   ğŸ’° Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ°: {corrected_revenue:,.0f} â‚½")
        logger.info(f"   ğŸ“¦ Ğ•Ğ´Ğ¸Ğ½Ğ¸Ñ† Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ½Ğ¾: {corrected_units:,.0f}")
        logger.info(f"   ğŸ’³ ĞšĞ¾Ğ¼Ğ¸ÑÑĞ¸Ñ: {corrected_commission:,.0f} â‚½")
        logger.info(f"   ğŸ’² ĞŸÑ€Ğ¸Ğ±Ñ‹Ğ»ÑŒ: {corrected_profit:,.0f} â‚½")

        return result

    def validate_against_expected(self, result: Dict) -> Dict:
        """Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹"""

        logger.info("\nâœ… Ğ’ĞĞ›Ğ˜Ğ”ĞĞ¦Ğ˜Ğ¯ ĞŸĞ ĞĞ¢Ğ˜Ğ’ ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞ«Ğ¥ Ğ—ĞĞĞ§Ğ•ĞĞ˜Ğ™:")

        expected_orders = 113595
        expected_delivered = 60688

        corrected_revenue = result.get('revenue', 0)
        corrected_orders_value = result.get('orders_stats', {}).get('price_with_disc', 0)

        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ
        revenue_ratio = corrected_revenue / expected_delivered if expected_delivered > 0 else 0
        orders_ratio = corrected_orders_value / expected_orders if expected_orders > 0 else 0

        validation = {
            'expected_delivered': expected_delivered,
            'corrected_revenue': corrected_revenue,
            'revenue_ratio': revenue_ratio,
            'revenue_match': abs(revenue_ratio - 1.0) < 0.2,  # Ğ’ Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… 20%

            'expected_orders': expected_orders,
            'corrected_orders_value': corrected_orders_value,
            'orders_ratio': orders_ratio,
            'orders_match': abs(orders_ratio - 1.0) < 0.2,  # Ğ’ Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ°Ñ… 20%
        }

        logger.info(f"   ğŸ¯ ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğµ Ğ²Ñ‹ĞºÑƒĞ¿Ñ‹: {expected_delivered:,.0f} â‚½")
        logger.info(f"   ğŸ”§ Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ²Ñ‹Ñ€ÑƒÑ‡ĞºĞ°: {corrected_revenue:,.0f} â‚½")
        logger.info(f"   ğŸ“Š Ğ¡Ğ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ: {revenue_ratio:.2f} ({'âœ… ĞĞš' if validation['revenue_match'] else 'âŒ ĞĞ• ĞĞš'})")

        logger.info(f"   ğŸ¯ ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹: {expected_orders:,.0f} â‚½")
        logger.info(f"   ğŸ”§ Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹: {corrected_orders_value:,.0f} â‚½")
        logger.info(f"   ğŸ“Š Ğ¡Ğ¾Ğ¾Ñ‚Ğ½Ğ¾ÑˆĞµĞ½Ğ¸Ğµ: {orders_ratio:.2f} ({'âœ… ĞĞš' if validation['orders_match'] else 'âŒ ĞĞ• ĞĞš'})")

        result['validation'] = validation
        return result

class CorrectedFinancialReports(RealDataFinancialReports):
    """Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ¾Ñ‚Ñ‡ĞµÑ‚Ğ¾Ğ²"""

    def __init__(self):
        super().__init__()
        self.corrected_processor = CorrectedWBDataProcessor()

    async def get_corrected_wb_data(self, date_from: str, date_to: str):
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… WB"""

        result = await self.corrected_processor.get_corrected_wb_data(date_from, date_to)

        if result:
            # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ
            result = self.corrected_processor.validate_against_expected(result)

        return result

async def test_corrections():
    """Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹"""

    logger.info("ğŸ§ª Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ™")
    logger.info("=" * 50)

    corrected_reports = CorrectedFinancialReports()

    # Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ° ÑĞ½Ğ²Ğ°Ñ€Ğµ 2025
    date_from = "2025-01-01"
    date_to = "2025-01-31"

    logger.info(f"ğŸ“… Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´: {date_from} - {date_to}")

    # ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
    corrected_data = await corrected_reports.get_corrected_wb_data(date_from, date_to)

    if corrected_data:
        logger.info("\nğŸ‰ Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ¯ Ğ£Ğ¡ĞŸĞ•Ğ¨ĞĞ ĞŸĞ Ğ˜ĞœĞ•ĞĞ•ĞĞ«!")

        validation = corrected_data.get('validation', {})
        if validation.get('revenue_match') and validation.get('orders_match'):
            logger.info("âœ… Ğ”ĞĞĞĞ«Ğ• Ğ¡ĞĞĞ¢Ğ’Ğ•Ğ¢Ğ¡Ğ¢Ğ’Ğ£Ğ®Ğ¢ ĞĞ–Ğ˜Ğ”ĞĞĞ˜Ğ¯Ğœ!")
        else:
            logger.info("âš ï¸ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±Ğ»Ğ¸Ğ·ĞºĞ¸ Ğº Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸ÑĞ¼, Ğ½Ğ¾ Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‚ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸")

        # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
        filename = f"corrected_data_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        filepath = f"/root/sovani_bot/reports/{filename}"

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(corrected_data, f, ensure_ascii=False, indent=2)
            logger.info(f"ğŸ’¾ Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½: {filepath}")
        except Exception as e:
            logger.error(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ: {e}")

        return corrected_data
    else:
        logger.error("âŒ ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
        return None

if __name__ == "__main__":
    result = asyncio.run(test_corrections())